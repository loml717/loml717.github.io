[{"content":"Python虚拟环境管理 什么是虚拟环境 python环境\nLib 用于放置 python 可调用的库，其中包含标准库和 site-pakages。site-pakages 用于存放下载的第三方库。 Scripts 用于存放可执行文件 python.exe 即为 python 解释器，用于运行 py 文件 虚拟环境\n虚拟环境实际上就是 python 文件夹的复制品，但与原环境有 3 点不同\n标准库不再被复制，直接调用原环境的标准库。site-pakages 文件夹里为空。 虚拟环境应该有自己的名称 python.exe 被移到到 Scripts 中 venv 基本使用 创建名为 venvdemo 的虚拟环境：python -m venv venvdemo\n**启动虚拟环境：**切换到文件目录 \\venvdemo\\Scripts 下，在 cmd 或 powershell 中输入 activate 即可激活，此时路径前会出现这样的字样 (venvdemo) ，说明激活成功\n保存和复制虚拟环境 输出环境中所包含的所有第三方包：pip freeze\n通过命令 pip freeze \u0026gt; requirements.txt 将环境的所有包信息保存到文件中，即可完美保存环境\n**恢复环境：**创建好虚拟环境后，将 requirements.txt 文件中的所有包安装至环境即可，pip install -r requirements.txt\n","date":"2024-10-11T00:00:00Z","image":"https://loml717.github.io/p/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86/python_virtual_enviroment_hu10285190429599348003.png","permalink":"https://loml717.github.io/p/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86/","title":"Python虚拟环境管理"},{"content":"中级\u0026ndash;软件设计师（知识点） 知识产权 著作权（版权） 人身权 发表权（期限：终身+50年）、署名权、修改权、保护作品完整权 财产权 专利地域性 各国主管机关依照本国法律授予的知识产权，只能在其本国领域内受法律保护（哪里申请，哪里保护）\n计算机软件著作权 主体与客体\n主体 计算机软件著作权的主体指享有著作权的人 根据规定：著作权法（《中华人民共和国著作权法》）、《计算机软件保护条例》 客体 计算机软件著作权的主体指著作权法保护的计算机著作权的范围（受保护的对象） 计算机程序：源程序和目标程序 计算机软件的文档：程序设计说明书、流程图和用户手册 根据规定：《著作权法》第三条、《计算机软件保护条例》第二条 权利\n人身权 发表权、开发者身份权（署名权） 财产权 保护期\n计算机软件著作权的权利自软件开发完成之日起产生，保护期为50年。保护期满，除开发者身份权外，其他权利终止。\n职务作品 职务软件作品指公民在单位任职期间为执行本单位工作任务所开发的计算机软件作品。（开发人员仅享有署名权）\n若开发的软件不是执行本职工作的结果，其著作权不属单位享有。如果该雇员主要使用了单位的设备，著作权不能属于该雇员个人享有。\n委托开发 接受他人委托开发的软件，其著作权的归属由委托者与受委托者签订书面合同约定；无书面合同或者书面合同未作明确约定的，其著作权由受托人享有。\n商业秘密权 商业秘密：指不为公众所知悉的，能为权利人带来经济利益、具有实用性并经权利人采取保密措施的技术信息和经营信息。\n专利权申请 专利申请原则 两个或者两个以上的人分别就同样的发明创造申请专利的，专利权授给最先申请人，同一时间则协商。 商标权 时间性\n我国商标权的保护期限自核准注册之日起10年内有效，但可以根据其所有人的需要无限地延长权利期限，在期限届满前6个月内申请续展注册，每次续展注册的有效期为10年 商标注册\n先注册先得，同一时间，先使用先得，未使用协商。 面向对象技术 类 一个类所包含的方法和数据描述一组对象的共同行为和属性。\n类是在对象之上的抽像，对象是类的具体化，是类的实例。\n类分为三种 实体类 其对象表示现实世界中真实的实体 接口类（边界类） 其为用户提供一种与系统合作交互的方式 控制类 其用来控制活动流，充当协调者 一般类与特殊类 一般类为特殊类的父类，特殊类为一般类的子类 对象 对象是基本的运行时的实体，它既包括数据（属性 | 状态），也包括作用与数据的操作（行为 | 方法 | 函数）。\n一个对象通常由对象名、属性和方法 3 个部分组成。\n消息 对象之间进行通信的一种构造叫作消息。\n当一个消息发送给某个对象时，包含要求接收对象去执行某些活动的信息。接收到信息的对象经过解释，然后予以响应。这种通信机制称为消息传递。\n方法重载 方法名相同，参数个数不同 方法名相同，参数类型不同 方法名相同，参数类型顺序不同 封装 封装是一种信息隐蔽技术，它的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。\n继承 继承是父类和子类之间共享数据和方法的机制。\n一个父类可以有多个子类，这些子类都是父类的特例，父类描述类这些子类的公共属性和方法。一个子类可以继承它的父类（或祖先类）中的属性和方法，这些属性和操作在子类中不必定义，子类还可以定义自己的属性和方法。\n单重继承：继承一个父类\n多重继承：继承两个及以上的父类\n多态 同类的不同的对象收到同一消息可以产生完全不同的结果，这一现象称为多态。\n父类 对象名 = new 子类 编译看左边，运行看右边\n多态的不同形式\n多态 通用的 参数：泛型 包含：父类引用子类 特定的 过载：重载方法 强制：强制类型转换 静态、动态绑定 绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程\n静态绑定：在编译时进行 动态绑定：在运行时进行 面向对象设计原则 单一责任原则 就一个类而言，应该仅有一个引起它变化的原因 开放-封闭原则 对扩展开放，对修改封闭 里氏替换原则 基类出现的地方，子类必定能出现 依赖倒置原则 依赖于抽象，而不依赖于细节（实现） 接口分离原则 依赖于抽象，而不依赖与具体 共同重用原则 重用包中的一个类，就要重用包中的所有类 共同封闭原则 一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成影响 面向对象 分析（OOA） 面向对象分析的目的是为了获得对应用问题的理解。理解的目的是确定系统的功能、性能的要求。\n5 个活动\n认定对象 定义问题域，将自然存在的 ‘名词’ 作为一个对象 组织对象 对象间的相互作用 基于对象的操作 定义对象的内部信息 设计（OOD） 面向对象设计是将 OOA 所创建的分析模型转化为设计模型，其目标是定义系统构造蓝图。\nOOD 在复用 OOA 模型的基础上，包含与 OOA 对应如下五个活动：\n识别类及对象 定义属性 定义服务 识别关系 识别包 测试 4 个层次\n算法层 类层 模板层 系统层 补充 类的静态方法只能访问该类的静态数据成员 静态数据成员可以被该类的所有方法访问 该类的对象共享其静态数据成员的值 在面向对象技术中，对象具有清晰的边界、良好定义的行为、可扩展性的特性 UML UML 统一建模语言，由 3 个要素构成，UML 的基本构造块、支配这些构造块如何放置在一起的规则、运用与整个语言的一些公共机制。\nUML 的词汇表包含 3 种构造块：\n事物 对模型中最具有代表性的成分的抽象 关系 把事物结合在一起 图 聚集了相关的事物 事物 4 种事物：\n结构事物（静态部分） 类、接口、协作、用例、主动类、构件、制品、结点 行为事物（动态部分） 交互、状态机、活动 分组事物（组织部分） 包 注释事物（解释部分） 注解 关系 4 种关系：依赖、关联、泛化、实现\n依赖关系 依赖是两个事物之间的语义关系，其中一个事物（独立事物）发生变化会影响另一个事物（依赖事物）的语义。\n关联关系 关联是一种结构关系，它描述了一组链，链是对象之间的连接。聚集是一种特殊类型的关联，它描述了整体和部分间的结构关系。\n在关联上可以标注重复度（多重度）和角色。\n聚集：部分和整体的生命周期不一致，整体消失了，部分仍然存在，部分可以脱离整体存在。\n组合：部分和整体的生命周期一致，整体消失了，部分也消失了，部分不可以脱离整体存在。\n关联多重度 多重度是指一个类的实例能够与另一个类的多少个实例相关联\n泛化关系 泛化是一种特殊/一般关系，特殊元素（子类）的对象可替代一般元素（父类）的对象。\n实现关系 实现是类元之间的语义关系，其中一个类元指定了由另一个类元保证执行的契约。\n图 静态建模：类图、对象图、用例图\n动态建模：序列图、通信图、状态图、活动图\n物理建模：构件图、部署图\n交互图：序列图、通信图\n类图 类图展现了一组对象、接口、协作和它们之间的关系。 类图一般包括类、接口、协作、依赖、泛化、关联。\n3 种方式使用类图\n对系统的词汇建模 对简单的协作建模 对逻辑数据库模式建模 对象图 对象图展示了某一时刻一组对象以及它们之间的关系。对象图一般包括对象、链。\n用例图 用例图展现了一组用例、参与者以及它们之间的关系。用例图一般包括用例、参与者、用例之间的扩展关系（\u0026laquo;extend\u0026gt;\u0026gt;）和包含关系（\u0026laquo;include\u0026gt;\u0026gt;）、参与者和用例之间的关联关系、用例与用例以及参与者与参与者之间的泛化关系。\n参与者：表示人、硬件或其他系统可以扮演的角色\n用例：一个类，代表一类功能而不是使用该功能的某一具体实例\n包含关系（用例\u0026amp;用例） 当某一用例被执行时，其箭头指向的用例（被包含用例）也会被执行。 扩展关系（用例\u0026amp;用例） 一个用例执行的时候，可能会发生一些特殊的情况或可选的情况，这种情况就是这个用例的扩展用例。 泛化关系（用例\u0026amp;用例 || 参与者\u0026amp;参与者） 序列图（顺序图） 序列图是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。\n序列图有两个不同于通信图的特征： 序列图有对象生命线，表示一个对象在一段时间内存在 序列图有控制焦点（生命线上的矩形），表示一个对象执行一个动作所经历的时间段 通信图（协作图） 通信图强调收发消息的对象的结构组织，展示对象之间的消息流及其顺序。\n通信图有两个不同于序列图的特性 通信图有路径 通信图有顺序号 序列图和通信图是同构的，它们之间可以相互转换。\n状态图 状态图展现了一个状态机，它由状态、转换、事件、活动组成，强调对象（单个）行为的事件顺序，通常对反应型对象建模。\n状态图用于描述一个对象在多个用例中的行为，用于某些具有多个状态的对象而不是系统中大多数或全部对象。\n状态 活动 活动表的语法格式：事件名（参数表）/动作表达式 事件 事件表达式语法格式：事件说明[监护条件]/动作表达式 转换（迁移） 转换可以包含事件触发器、监护条件、状态（两个） 状态图可以没有终止状态。\n转换包括两个状态（源状态，目标状态）。\n事件触发转移（迁移）。\n活动（动作）可以在状态内执行，也可以在状态转换（迁移）时执行。\n组合状态也称超状态，嵌套状态也称子状态\n活动图 活动图是一种特殊的状态图，它展现了在系统内从一个活动到另一个活动的流程。\n构件图 构件图展现了一组构件之间的组织和依赖。通常把构件映射为一个或多个类、接口或协作。\n部署图 部署图是用来对面向对象系统的物理方面建模的方法，展现了系统的软件和硬件之间的关系，在实施阶段使用。\n软件工程 软件过程 能力成熟度模型（CMM） CMM 将软件过程改进分为以下 5 个成熟度级别：\n初始级 软件过程的特定是杂乱无章，有时甚至混乱，几乎没有明确定义的步骤，项目的成功完全依赖个人努力和英雄式核心人物的作用 可重复级 建立了基本的项目管理过程和实践来跟踪项目费用、进度和功能特性，有必要的过程准则来重复以前在同类项目中的成功 已定义级 软件过程文档化、标准化，并综合成整个软件开发组织的标准软件过程。所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件。 已管理级 制定了软件过程和产品质量的详细度量标准。软件过程的产品质量都被开发组织的成员所理解和控制。 优化级 加强了定量分析，通过来自过程质量反馈和来自新观念、新技术的反馈使过程能不断持续地改进。 能力成熟度模型集成（CMMI） CMMI提供了两种表示方法：阶段式模型和连续式模型\n1）阶段式模型\n初始的：过程不可预测且缺乏控制 已管理的：过程为项目服务 已定义的：过程为组织服务 定量管理的：过程已度量和控制 优化的：集中于过程改进 2）连续式模型\nCL0（未完成的） 过程域未执行或未得到 CL1 中定义的所有目标。 CL1（已执行的） 其共性目标是过程将可标识的输入工作产品转换成可标识的输出工作产品，以实现支持过程域的特定目标。 CL2（已管理的） 其共性目标集中于已管理的过程的制度化。根据组织级政策规定过程的运行将使用哪个过程，项目遵循已文档化的计划和过程描述，所有正在工作的人都有权使用足够的资源，所有工作任务和工作产品都被监控、控制和评审。 CL3（已定义级的） 其共性目标集中于已定义的过程的制度化。过程是按照组织的剪裁指南从组织的标准过程集中剪裁得到的，还必须收集过程资产和过程的度量，并用于将来对过程的改进。 CL4（定量管理的） 其共性目标集中于可定量管理的过程的制度化。使用测量和质量保证来控制和改进过程域，建立和使用关于质量和过程执行的定量目标作为管理准则。 CL5（优化的） 使用量化（统计学）手段改变和优化过程域，以满足客户要求的改变和持续改进计划中的过程域的功效。 软件过程模型 软件过程模型也称为软件开发模型，它是软件开发全部过程、活动和任务的结构框架。\n瀑布模型 只适用于需求明确或者二次开发（需求稳定）。\n优点 容易理解，管理成本低 强调开发的阶段性早期计划及需求调查和产品测试 缺点 客户必须能够完整、正确、清晰的表达他们的需要 难以评估进度状态 接近项目结束时，出现大量的集成和测试工作 V模型 特点是增加了多轮测试。\n增量模型 优先级最高的服务最先交付，但由于并不是从系统整体角度规划各个模块，因此不利于模块划分。\n优点 瀑布模型的优点 第一个可交付版本所需成本和时间很少 开发承担的风险不大 可减少用户需求的变更 运行增量投资 缺点 初始增量可能会造成后来增量的不稳定 需求不稳定，可能导致一些增量需重新开发 管理发生的成本、进度和配置的复杂性可能会超出组织的能力 演化模型 演化模型是迭代的过程模型，使得软件开发人员能够逐步开发出更完整的软件版本。演化模型特别适用于对软件需求缺乏准确认识的情况。\n原型模型 原型方法比较适合于用户需求不清、需求经常变化的情况。当系统规模不是很大也不太复杂时，采用该方法比较好。\n螺旋模型 螺旋模型将瀑布模型和演化模型结合起来，加入了风险分析。适用于庞大、复杂且具有高风险的系统。\n喷泉模型 喷泉模型是一种以用户需求为动力，以对象作为驱动的模型，适合于面向对象的开发方法。\n喷泉模型克服了瀑布模型不支持软件重用和多项开发活动集成的局限性\n优点 各个阶段没有明显界线，开发人员可以同步进行，提高软件项目的开发效率，节省开发时间 缺点 由于各个开发阶段是重叠的，在开发过程中需要大量的开发人员，不利于项目的管理 这种模型要求严格管理文档，使得审核难度加大 统一过程模型（UP） 统一过程定义了 4 个技术阶段及其制品\n起始阶段：生命周期目标 专注于项目的初创活动 精化阶段：生命周期架构 理解了最初的领域范围之后进行需求分析和架构演进 构件阶段：初始运作功能 关注系统的构建，产生实现模型 移交阶段：产品发布 关注于软件提交方面的工作，产生软件增量 敏捷方法 极限编程（XP） 极限编程由价值观、原则、实践、行为 4 个部分组成\n4 大价值观 沟通、简单性、反馈、勇气 5 个原则 快速反馈、简单性假设、逐步修改、提倡更改、优质工作 12 个最佳实践 计划游戏（快速制定计划、随着细节不断变化而完善）、小型发布、隐喻（找到合适的比喻传达信息）、简单设计、测试先行、重构、结对编程、集体代码所有制、持续集成、每周工作 40 小时、现场客户、编码标准 水晶法 水晶法认为每一个不同的项目都需要一套不同的策略、约定和方法论\n并列争求法 并列争求法使用迭代的方法，其中，把每 30 天一次的迭代称为一个“冲刺”\n自适应软件开发（ASD） ASD 有 6 个基本的原则\n敏捷统一过程（AUP） 敏捷统一过程采用“在大型上连续”以及“在小型上迭代”的原理来构建软件系统。\n每个 AUP 迭代执行以下活动：\n建模 实现 测试 部署 配置及项目管理 环境管理 软件需求 12 种需求\n功能需求 考虑系统要做什么，何时做，在何时以及如何修改或升级 性能需求 考虑软件开发的技术性指标 用户或人的因素 考虑用户的类型 环境需求 考虑未来软件应用的环境，包括硬件和软件 界面需求 考虑来自其他系统的输入，到其他系统的输出，对数据格式的特殊规定，对数据存储介质的规定 文档需求 考虑需要哪些文档，文档针对哪些读者 数据需求 考虑输入、输出数据的格式，接收、发送数据的频率，数据的准确性和精度、维护所需的人力、支撑软件、开发设备等 资源使用需求 考虑软件运行时所需要的数据、其他软件、内存空间等资源；软件开发、维护所需的人力、支撑软件、开发设备等 安全保密要求 考虑是否需要对访问系统或系统信息加以控制，隔离用户数据的方法，用户程序如何与其他程序和操作系统隔离以及系统备份的要求 可靠性要求 考虑系统的可靠性要求，系统是否必须检测和隔离错误；出错后，重启系统允许的时间等 软件成本消耗与开发进度需求 考虑是否有规定的时间表，软/硬件投资有无限制等 其他非功能性要求 系统设计 概要设计 设计软件系统总体结构 将一个复杂的系统按功能划分成模块 确定每个模块的功能 确定模块之间的调用关系 确定模块之间的接口，即模块之间传递的信息 评价模块结构的质量 数据结构及数据库设计 编写概要设计文档 评审 详细设计 对每个模块进行详细的算法设计，用某种图形、表格和语言等工具将每个模块处理过程的详细算法描述出来 对模块内的数据结构进行设计 对数据库进行物理设计 其他设计 编写详细设计说明书 评审 系统测试 系统测试是为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试\n测试的目的就是希望能以最少的人力和时间发现潜在的各种错误和缺陷\n基本原则：\n应尽早并不断进行测试 测试工作应该避免由原开发软件的人或小组承担，一方面开发人员往往否认自己的工作，另一方面具有局限性 在设计测试方案时，不仅要确定输入数据，而且要根据系统功能确定预期输出结果 在设计测试用例时，不仅要设计有效合理的输入条件，也要包含不合理、失效的输入条件 在测试程序时，不仅要检查程序是否做了该做的事，还要检验是否做了不该做的事 严格按照测试计划来进行，避免测试的随意性 妥善保存测试计划、测试用例，作为软件文档的组成部分，为维护提供方便 测试例子都是精心设计出来的，可以为重新测试或追加测试提供方便 系统测试阶段的测试目标来自于需求分析阶段 单元测试 单元测试也称为模块测试，在模块编写完成且无编译错误后就可以进行\n单元测试的测试内容 主要检查模块的以下 5 个特征：\n模块接口 局部数据结构 重要的执行路径 出错处理 边界条件 单元测试过程 由于模块不是独立运行的程序，各模块之间存在调用于被调用的关系。在对每个模块进行测试时，需要开发两种模块。\n驱动模块 相当于一个主程序，接收测试例子的数据，将这些数据送到测试模块，输出测试结果 桩模块 桩模块用来代替测试模块中所调用的子模块，其内部可进行少量的数据处理，目的是为了检验入口，输出调用和返回信息 集成测试 集成测试就是把模块按系统设计说明书的要求组合起来进行测试\n集成测试方法：\n自顶向下集成测试（不需要驱动模块，需要桩模块） 自底向上集成测试（不需要桩模块，需要驱动模块） 低层构件集成为簇 回归测试 冒烟测试（知道有就行） 测试方法 软件测试方法分为静态测试和动态测试\n静态测试 静态测试是指被测程序不在机器上运行，而是采用人工检测和计算机辅助静态分析的手段对程序进行检测 动态测试 动态测试是指通过运行程序发现错误。在对软件产品进行动态测试时可以采用黑盒测试法和白盒测试法 黑盒测试 黑盒测试也称为功能测试，在完全不考虑软件内部结构和特性的情况下，测试软件的外部特性\n常用黑盒测试技术：\n等价类划分 将程序的输入域划分为若干等价类，然后从每个等价类中选取一个代表性数据作为测试用例（等价类分为有效等价类和无效等价类） 边界值分析 边界值划分选择等价类边界的测试用例，既注重于输入条件边界，又适用于输出域测试用例 错误推测 错误推测是基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性地设计测试用例的方法 因果图 因果图法是从自然语言描述的程序规格说明中找出因（输入条件）和果（输出或程序状态的改变），通过因果图转换为判定表 白盒测试 白盒测试也称为结构测试，根据程序的内部结构和逻辑设计测试用例，对程序的路径和过程进行测试，检查是否满足设计的需要。\n","date":"2024-10-11T00:00:00Z","permalink":"https://loml717.github.io/p/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/","title":"软件设计师"},{"content":"网络协议 网络协议是计算机网络中进行数据交互而建立的一种规则，即一套约定、标准的集合。\nOSI七层模型 七层模型 层概念 层功能 协议 物理层 数据链路层 物理链路层 以二进制的数据形式在物理媒介上进行传输数据 ISO@2100 网络层 网络 为数据包选择路由 IP、ICMP、BGP、OSPF 传输层 传输 提供端对端的接口 TCP、UDP 会话层 表示层 应用层 最接近用户的应用层 提供文件传输、邮件、文件共享、数据加密等等 HTTP、SNMP、FTP、NFS、DNS 1、应用层 通过进程间的数据交互来完成特定的网络应用，对于不同的网络应用需用不同的网络协议。如，web 服务用 HTTP 协议、邮件传输用 SMTP 协议。应用层间交互的数据称之为报文。\nDNS 协议\n域名解析系统（DNS\tDomain Name System），DNS 是互联的一个分布式数据库，主要存储 IP 和域名的对应关系，能够让用户更方便的访问互联网，而不用记住繁琐的 ip 地址。\nHTTP 协议\n超文本传输（HTTP\tHyperText Transfer Protocol），为了便于发布和接受 HTML 文件。\n2、传输层 为两台主机之间的进程进行提供数据传输。\nTCP 协议\n传输控制协议（TCP\tTransmission Control Protocol），提供面向连接的、可靠的数据传输服务。\nUDP 协议\n用户数据协议（UDP\tUser Datagram Protocol），提供无连接的数据传输，不保证数据安全可靠性。UDP 无报文，支持一对一、一对多、多对一、多对多的交互通信。\n","date":"2024-10-07T16:38:15+08:00","permalink":"https://loml717.github.io/p/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/","title":"网络协议"},{"content":"Git使用教程 初始化配值 安装 官网上点击下载即可，除安装位置外，只需点击下一步。。。 初始化配置 配置用户名和邮箱 git config --global user.name \u0026quot;loml717\u0026quot; git config --global user.email loml717@learn.com，用于标识提交内容的身份是谁 省略（Local）：本地配置，只对本地仓库有效 \u0026ndash;global：全局配置，所有仓库生效 \u0026ndash;system：系统配置，对本电脑所有用户生效 保存用户名和密码 git config --global credential.helper store 查看 Git 配置信息 git config --global --list 新建版本库 创建仓库的两种方式：\n本地创建仓库：git init\n通过添加参数，如 git init my-repo 则会创建一个名为 my-repo 的仓库\n通过 git init 初始化本地仓库后，git 会在当前文件夹下创建 .git 文件夹，用于保存该文件夹的仓库信息，并表明该文件夹为一个仓库。删除 .git 文件夹，则表明该文件夹不是仓库。\n从远程服务器克隆一个仓库：git clone\ngit clone \u0026lt;远程仓库地址\u0026gt; 即可将远程仓库创建至本地 Git的工作区域和文件状态 Git 的数据管理可分为三个区域：\n工作区：实际操作的目录，.git 所在的目录 暂存区：临时存放即将提交的修改内容 本地仓库：Git 存储代码的版本信息的主要位置 Git 文件中的几种状态：\n未跟踪：新创建的尚未被 git 管理 未修改：被 git 管理，但内容没有变化 已修改：修改了，尚未添加至暂存区 已暂存：修改后添加到暂存区 Git 基本使用语法 git status 查看仓库的状态\n参数：\n-s：表示简略模式显示仓库状态， Untracked files：文件为跟踪，表示文件处于工作区\ngit add 将文件添加到暂存区\n文件显示为绿色时，代表文件存放在暂存区\n注意！！！ 使用 git rm --cache \u0026lt;file\u0026gt; 可以将文件从暂存区撤回工作区\ngit commit 提交文件到仓库中（将暂存区中的文件提交到仓库中）\n-m 参数：该参数用于描述提交的信息。建议每次提交都带上，否则会强制进入文本输入（eg：vim）要求你输入信息\n**小技巧：**使用 git -a -m \u0026quot;\u0026quot; 可以同时完成提交和暂存两个动作\ngit log 用于查看提交记录\n使用参数 git log --oneline 仅显示提交的 ID 和提交信息\n回退版本 git reset \u0026ndash;soft 回退到某一个版本，并且保留工作区和暂存区的所有修改内容\ngit reset \u0026ndash;hard 回退到某一个版本，并且丢弃工作区和暂存区的所有修改内容\ngit reset \u0026ndash;mixed 默认参数\n回退到某一个版本，保存工作区的修改内容，丢弃暂存区的修改内容\ngit reflog 查看操作的历史记录，可借助操作的历史记录和 git reset --hard 回溯到之前某一个误操作的命令之前\n查看差异 git diff 用于查看工作区、暂存区、本地仓库之间的差异，也可用于查看文件在两个特定版本或分支之间的差异\n不加参数\n默认比较工作区和暂存区之间的差异，显示发生更改的文件以及更改的详细信息\nHEAD 参数：\n比较工作区和版本库之间的内容\n\u0026ndash;cached 参数：\n比较暂存区和版本库之间的内容\n结果同上图\ngit diff \u0026lt;版本提交 ID1\u0026gt; \u0026lt;版本提交 ID2\u0026gt; [指定文件名称]\n比较（可指定）文件两次不同版本之间的差异\n补充：HEAD 可用于表示当前分支的最新提交，HEAD~ 或 HEAD^ 可用于表示上一次提交，加数字可表示多个之前的版本（eg: HEAD~2 表示当前版本的前两个版本）\n删除文件 两种方式：\n借助 git 更新版本达到删除文件的目的 从工作区删除文件（即删除本地文件） 从暂存区删除文件（使用 git add . 更新工作区文件到暂存区） 从本地仓库删除文件（使用 git commit 更新暂存区到本地仓库中） 从而达到删除文件的目的 使用 git rm 命令 该命令会同时删除工作区和暂存区中的文件，但本地仓库中任然存在该文件，需重新提交从而从本地仓库中删除文件。\n参数：\ngit rm \u0026lt;file\u0026gt; 把文件从工作区和暂存区同时删除 git rm --cached \u0026lt;file\u0026gt; 把文件从暂存区中删除，但保留在当前工作区中 git rm -r * 递归删除某个目录下的所有子目录和文件 忽略文件 .gitignore 文件可使该文件夹下的某些文件（为被添加到版本库中的文件）被忽略，不被加入到版本库中。\n应该忽略的文件\n系统或者软件自动生成的文件 编译产生的中间文件和结果文件 运行时生成日志文件、缓存文件、临时文件 涉及身份、密码、口令、密钥等敏感信息文件 文件的匹配规则\n从上到下逐行匹配，一行表示一个忽略模式 空行或 # 开头的行会被忽略 使用标准的 glob 模式匹配 ** 表示匹配任意的中间目录 ! 表示取反，即指定文件一定不会被忽略 远程仓库 远程仓库和本地仓库是相互独立的两个仓库，克隆仓库即指把远程仓库的所有内容复制到本地。\n远程仓库地址的两种方式： HTTPS 每次 push 需验证用户名和密码（不推荐） SSH push 时不需要用户名和密码，但需要在 github 上添加 SSH 公钥配置 配置 SSH 密钥 使用 ssh 方式连接远程仓库，必须配置 ssh 密钥\n！！！建议配置时，上网查阅，此处记录较为简陋\n使用该命令ssh-keygen -t rsa -b 4096 用于生成密钥\n执行后，会生成密钥文件（id_rsa）和公钥文件(id_rsa.pub)，将公钥填入账户配置中即可。(如果指定文件名称，则会生成对应的文件及文件.pub，同时还需再进一步配置)\n克隆仓库 克隆仓库 git clone repo-address 推送更新内容 git push \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; 拉取更新内容 git pull \u0026lt;remote\u0026gt; 关联本地仓库和远程仓库 建立本地仓库和远程仓库的关联：\n建立连接：git remote add \u0026lt;shortname\u0026gt; \u0026lt;url\u0026gt; 将本地仓库与远程仓库连接起来，其中 shortname 设置远程仓库的别名，url 为远程仓库的地址 查看仓库信息：git remote -v 查看当前仓库所对应的远程仓库的别名和地址 指定本地分支名称：git branch -M main 建立关联分支：git push -u origin main:main 将本地仓库的 main 分支和远程仓库的 main 分支关联起来，若本地与远程分支名相同，建立连接时可省略冒号后面部分 同步远程仓库与本地仓库的内容\ngit pull \u0026lt;远程仓库别名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; 将远程仓库文件拉取到本地再合并（可能会因内容冲突而失败） 省略参数默认为 git pull origin main git fetch 与该命令相同，都可以从远程仓库获取修改的内容，但不会自动合并，需手动合并 分支 分支的基本操作 查看当前所有分支：git branch\n创建新分支：git branch \u0026lt;分支名\u0026gt;\n切换不同分支：git checkout \u0026lt;分支名\u0026gt;\ngit checkout 也可用于恢复文件，若出现文件名与分支名相同的情况，则默认为切换分支 git switch \u0026lt;分支名\u0026gt; 专门用于切换分支名 合并分支：git merge \u0026lt;分支名\u0026gt;\n将指定分支合并到当前分支 查看分支图：git log --graph --oneline --decorate --all\n删除分支：git branch -d\n-d：只能删除已经被合并的分支 -D：强制删除分支 解决合并冲突 当两个分支中出现同一份文件的同一行代码出现差异时，就会发生合并冲突\n当发生合并冲突时，需到文件对应位置进行修改再提交\n中断合并：git merge --abort\n回退和rebase 回退分支 回退到某一分支：git checkout -b \u0026lt;分支名\u0026gt; \u0026lt;对应分支ID\u0026gt; rebase变基 git rebase \u0026lt;分支名\u0026gt;\nrebase执行的操作：\nMerge和Rebase merge 优：不会破坏原分支的提交历史，方便回溯和查看 缺：产生额外提交节点，分支图比较复杂 rebase 优：不新增额外的提交记录，形成线性历史，直观干净 缺：改变提交历史，改变当前分支 branch out 的节点，避免在共享分支使用 ","date":"2024-09-29T17:15:03+08:00","image":"https://loml717.github.io/p/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/git_hu15283378056538356560.png","permalink":"https://loml717.github.io/p/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"Git使用教程"},{"content":"通过regedit使win10任务栏透明 通过 win + R 输入 regedit 打开注册表\n定位到目录计算机\\HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\n右侧空白处右键，新建→DWORD (32位) 值，并将其重命名为 TaskbarAcrylicOpacity\n双击文件，选择十进制，调整数据数值，0为完全透明，10为完全不透明，点击确定即可\n效果\n建议！（效果应该会更好点）\n将颜色选择为自定义，并修改为如下：\n","date":"2024-09-28T10:23:47+08:00","image":"https://loml717.github.io/p/win10%E4%BB%BB%E5%8A%A1%E6%A0%8F%E9%80%8F%E6%98%8E/5_hu20553926082269395.png","permalink":"https://loml717.github.io/p/win10%E4%BB%BB%E5%8A%A1%E6%A0%8F%E9%80%8F%E6%98%8E/","title":"Win10任务栏透明"}]